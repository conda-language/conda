//rat.ohm
/*
Rat v1.2.0
Changes:
- Types no longer keywords (analyzer will handle this)
- Type conversion will also be handled by analyzer
- removed 'Iterable' type
- removed 'as' and 'import' keywords
- 
*/
Rat {
    // Unsure whether we should change to Stmt* for non-empty files as most programming languages will still do empty files
    Program = Stmt*
    // here, we define valid statements
    //=========== (VALID STATEMENTS) ============== //
    Stmt = print "("Exp ")" ";"                         --print
        | (const|var) id ":" Type "=" Exp ";"           --vardec
        | LhsExp op? "=" Exp ";"                        --assign
        | while Exp Block                               --while
        | ForStmt
        | Call ";"                                      --call
        | IfStmt
        | pass ";"                                      --pass
        | break ";"                                     --break
        | return Exp ";"                                --return 
        | TryStmt
        | FuncDecl

    LhsExp = id Index*
    TryStmt = try Block (timeout Block)? catch Params Block
    FuncDecl = (Type|void) id Params Block
 

    // Change if statement by separating ifStmt and ShortStmt:
    //IfStmt = if Exp Block else Block
    //ShortifStmt = if Exp Block
	
    IfStmt = if Exp Block                                --if
        | if Exp Block else Block                        --else
        | if Exp Block else IfStmt                       --elseif
    // depending on whether the '...', '..<' or an identifier of an iterable object is present, will determine the type of the 'id'
    ForStmt  = for id in (id|InclusiveRng|ExclusiveRng) Block
    // while we generally statically type our language, in cases like this, where we iterate through a 
    // range of numbers, we will assume that the id is going to be an integer
    
    Call = id Args
    Index = "[" Exp "]"
    Params = "("ListOf<Param, ",">")"
    Param = id ":" Type
    Args = "(" ListOf<Exp, ","> ")"
    Block = "{" Stmt* "}"

    // lowest precedence
    Exp = Exp0 "??" Exp0                                                            --unwrap
        | Exp0
        | ("-"|"!") Primary                                                         --unary
        | await ("<<" Exp  ">>" )? ( one | all )? Exp                               --await
    Exp0 = Exp "||" Disjunct                                                        --logicalor
         | Disjunct
    Disjunct = Disjunct "&&" Conjunct                                               --logicaland
             | Conjunct
    // Non-associative relational operators
    Conjunct = Comp ( "<=" | "<" | "==" | "!=" | ">=" | ">" ) Comp                  --comparative
             | Comp
    Comp = Comp ( "+" | "-" ) Term                                                  --additive
         | Term
    // ^left associativity
    Term = Term ( "*" | "/" | "%" ) Factor                                          --multiplicative
         | Factor
    // Right associativity + Highest precedence
    Factor = Primary "**" Factor                                                    --exponent
           | Primary
    // possible assignables to variables
    Primary = floatlit 
            | intlit 
            | true 
            | false 
            | none
            | ArrayLit
            | DictLit
            | some Exp                                              --wrapped
            | Primary ("[" | "?[") Exp "]"                          --index
            | Call
            | id                                                    --id
            | Parens
            | strlit

    ArrayLit = "["ListOf<Exp, ",">"]"
    DictLit = "{" ListOf<Binding,",">"}"
    Parens = "(" Exp ")"


    //key:value pairs for dictionaries
    Binding = Exp ":" Exp
    InclusiveRng = Exp "..." Exp
    ExclusiveRng = Exp "..<" Exp
    op = "**" | "*" | "/" | "%" |"+" | "-"

    Type = Type "?"                                         --optional
         | Type "^"                                         --promise
         |"[" Type "]"                                      --array
         | "[" Type":"Type"]"                               --dictionary
         | id                                               --id

    //KEYWORDS:
    print   = "print" ~idchar
    true    = "true" ~idchar
    false   = "false" ~idchar
    let     = "let" ~idchar
    in      = "in" ~idchar
    const   = "const" ~idchar
    var     = "var" ~idchar
    while   = "while" ~idchar
    for     = "for" ~idchar
    if      = "if" ~idchar
    else    = "else" ~idchar
    break   = "break" ~idchar
    return  = "return" ~idchar
    some    = "some" ~idchar
    none    = "None" ~idchar
    anything= "anything" ~idchar
    pass    = "pass" ~idchar
    await   = "await" ~idchar
    try     = "try" ~idchar
    catch   = "catch" ~idchar
    one     = "one" ~idchar
    void    = "void" ~idchar
    all     = "all" ~idchar
    timeout = "timeout" ~idchar
    // import  = "import" ~idchar
    // as      = "as" ~idchar
    from    = "from" ~idchar

    // await used for asynchronous functions that perform a call that is promised to return a value
    // await one - used for having an array of promise types, will return value when one promise is fulfilled
    // await all - will return an array of promise strings.  
    // in asynchronous functions, we can choose to timeout the function if it takes to long to return something
    // distinguishes keywords

    keyword = print | true | false | let | pass
            | while | for | if | else | else | return
            | some  | void | await | one | all | none
            | from

    //allows you to name your variables
    id = ~keyword (letter| "_") idchar*
    idchar = (alnum|"_")

    strlit = "\"" char* "\""
    intlit = digit+
    floatlit = digit+ "." digit+ (("E"|"e") ("+"|"-")? digit+)?
    //valid characters in a string

    char = "\\n"                                                                --newlineescape
        |"\\t"
        |"\\\\"
        |"\\\""
        |"\\u{" hexDigit hexDigit? hexDigit? hexDigit? hexDigit? hexDigit?"}"   --usecape
        |~"\"" ~"\n" ~"\\" any                                                  --regular
    space += "#" (~"\n" any)*                                                   --comment
}
